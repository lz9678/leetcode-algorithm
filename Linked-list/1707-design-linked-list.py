
# Method 1: Single Linked List

class ListNode:
  def __init__(self, val=0, next=None):
      # create a class to represent the node in the linked list
        self.val = val
        self.next = next

class MyLinkedList:
    def __init__(self):
        # why don't we need to add next = head in the ListNode()?
        # how do we find the head?
        # why is the size equal to 0 here?
        self.dummy_head = ListNode()
        self.size = 0
        
    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1

        current = self.dummy_head.next
        for i in range(index):
            current = current.next
        return current.val
        
    def addAtHead(self, val: int) -> None:
        # how to understand the dummy_head.next on the right and left side?
        # what is next in the node class?
        self.dummy_head.next = ListNode(val = val, next = self.dummy_head.next)
        self.size += 1
        # no need to add return since this function is set to return to None

    def addAtTail(self, val: int) -> None:
        current = self.dummy_head
        while current.next:
            current = current.next
        current.next = ListNode(val)
        self.size +=1

    def addAtIndex(self, index: int, val: int) -> None:
        if index > self.size:
            return None
        
        current = self.dummy_head.next
        prev = None
        for i in range(index):
            prev = None
            current = current.next
        prev.next = ListNode (val=val, next = current)
        self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        
        current = self.dummy_head
        for i in range(index):
            current = current.next
        # what does the current.next on the left and right side mean?
        # if index is equal to size, this will also work
        current.next = ListNode(val, current.next)
        self.size += 1
    

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        
        current = self.dummy_head
        for i in range(index):
            current = current.next
        current.next = current.next.next
        self.size -= 1

# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)


''' Notes:
1. __init__ is a special method, also known as a constructor, that is automatically called when you create an instance (object) of a class in Python. It is used to initialize the attributes or properties of the object. Below is an example:
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
2. self: It is a reference to the instance of the class that is being created.
3. Why do we need a pointer current instead of directly using head? We need a pointer to iterate, and do not want to make changes to head which will need to return to in the end.
4. Use dummy_head to simplify the solutions for all the functions here (add and delete).
5. For loop automatically iterates through the values generated by range(size). The loop variable i takes on each value from 0 to size-1 in each iteration, and the loop advances without the need for manual incrementation.
'''

# Method 2: Double Linked List [To add]